# 一、函数

函数（Function）

+ 函数也是一个对象
+ 它具有其他对象所有的功能，并且函数中可以存储代码，且可以在需要时调用这些代码

## 1.1 函数创建方式

### 1.1.1 函数声明

+ 语法

  + `````javascript
    function 函数名([参数，参数...]){
    	语句...
    }
    `````

### 1.1.2 函数表达式

+ 语法

  + ``````````javascript
    const fn2 = function([参数，参数...]){
        语句...
    }
    ``````````

### 1.1.3 箭头函数

+ 基本语法

  + `````javascript
    const fn3 = ([参数，参数...]) => {
    	语句...
    }
    `````
  
+ 特殊写法

  + 无参箭头函数 `() => 返回值`
  + 一个参数的 `a => 返回值`
  + 多个参数的 (参数1，参数2) => 返回值
  + 只有一个语句的箭头函数 `() => 返回值`
  + 只返回一个对象的箭头函数`() => ({...})`
  + 多行语句的函数 `() => {语句...return ...}`


## 1.2 调用函数

调用函数就是执行函数中储存的代码

+ 语法
  + `函数对象 ()`

## 1.3 函数参数

+ 传递参数时，传递的并不是变量本身，而是变量中存储的值

### 1.3.1 形式参数

+ 在定义函数时，可以在函数中括号中指定数量不等的形式参数(形参)
+ 在函数中定义形参，就相当于在函数内部声明了对应的变量但是没有赋值

### 1.3.2 实际参数

+ 在调用函数时，可以在调用函数的中括号里传递数量不等的实参
+ 实参会赋值给其对应的形参

### 1.3.3 参数特殊情况

1. 如果实参和形参数量相同，则对应的实参赋值给对应的形参
2. 如果实参多余形参，则多余的实参不会使用
3. 如果形参多余实参，则多余的形参没有被赋值，则会为undefined

### 1.3.4 参数类型

1. JS中不会检查参数的类型，可以传递任何类型的值作为参数

### 1.3.5 箭头函数的参数

1. 当箭头函数中有参数且只有一个参数，可以省略()

+ `````````````javascript
          let fn1 = a => {
              console.log('a = ',a);
          }
        
          fn1() // a = undefined

### 1.3.6 参数默认值

1. 定义形参时，可以为形参赋值，可以理解为给参数指定默认值
2. 参数默认值会在没有实参时生效
2. 函数默认值每次调用都会创建新的默认值

+ `````````javascript
          const fn3 = (a=10 , b=20 , c=30) => {
              console.log('a = ',a);
              console.log('b = ',b);
              console.log('c = ',c);
          }
        
          fn3(15,15) // 15 15 30

### 1.3.7 对象作为参数

+ 对象可以作为参数传递为实参

+ ``````javascript
  function fn(a){
      console.log(a.name);
  }
          
  let obj = {
      name:'孙悟空'
  }
  
  fn(obj) // 孙悟空
  ``````

+ 函数每次调用，都会重新创建默认值，函数的上一次影响不会改变函数第二次执行的内容
+ 如果不是默认值调用对象，而是函数外部的对象，则会修改对象内的数据，因为不是默认值则不会每一次调用都会重新创建，所以会一直出现覆盖的值

### 1.3.8 函数作为参数

1. 在JS中，函数也是一个对象（一等函数）别的对象能做的事，函数也可以，函数也可以作为参数使用

+ ```````````javascript
  function fn(a){
      a()
  }     
  
  function fn2(){
      console.log('我是fn2');
  }
  
  fn(fn2) // 我是fn2
  ```````````

### 1.3.9 回调函数

+ 一个函数的参数也可以是函数，如果将函数作为参数传递，那么我们就称这个函数为回调函数（callback）

+ ``````````````javascript
          // 过滤出符合条件的对象
          function inspectAgeMid18(personArr , cb){
              let newArrey = []
              console.log(cb);
              for (let i = 0; i < personArr.length; i++) {
                  if (cb(personArr[i])) {
                      newArrey.push(personArr[i])
                  }
              }
              return newArrey
          }
          console.log(inspectAgeMid18(personArr , a => 			a.age < 18 ));
  ``````````````

+ 为什么要将函数作为参数传递（回调函数有什么作用？）

  1. 将函数作为参数，意味着可以对另一个函数动态传递代码

## 1.4 函数返回值

### 1.4.1 一般函数返回值

1. 在函数中，可以通过return关键字来指定函数的返回值

   + 返回值就是函数的执行结果，函数调用完毕返回值便会作为结果返回

   + ```````````
             function fn(a , b){
                 return a + b
             }    
             
             let a = fn(7 , 8)
           
             console.log(a); // 15

2. JS中，任何值都可以作为返回值返回(包含对象和函数之类)

3. 如果return后不跟任何值，则相当于返回undefined

4. 如果不写return，那么函数的返回值依然是undefined

5. return执行，函数立即结束

### 1.4.2 箭头函数返回值

1. 箭头函数的返回值可以直接写在箭头后

+ ````javascript
  const sum = (a , b) => a + b 
  
  let result = sum(50,50)
  
  console.log(result);
  ````

#### 1.4.2.1 箭头函数返回值特殊情况

箭头函数返回值为对象的特殊情况

1. 用箭头函数返回值的方式在后面直接返回一个对象，此时会返回undefined，函数会认为对象的大括号是代码块的大括号，没有设置return所以返回值为undefined

   + ``````````````javascript
             const fn = () => {name:'孙悟空'}
             result = fn()
             console.log(result); //undefined
     ``````````````

解决方法

1. 为对象外加上一个中括号，让函数分清楚函数代码块与对象代码块
   + `const fn = () => ({name:'孙悟空'})`

## 1.5 作用域（scope）

+ 作用域指的是一个变量的可见区域

### 1.5.1 全局作用域

全局作用域特点

1. 全局作用域在网页运行时创建，在网页关闭时销毁
2. 所有直接编写到script标签中的代码都位于全局作用域中
3. 全局作用域中的变量是全局变量，可以在任意位置访问

### 1.5.2 局部作用域

1. 在局部作用域（包含块作用域和函数作用域）中，如果没有使用var 或 let 声明变量，则变量会自动成为window对象的属性，也就是全局变量

#### 1.5.2.1 块作用域

块作用域特点

1. 块作用域是一种局部作用域
2. 块作用域在代码块执行时创建，代码块执行完毕它就销毁
3. 在块作用域中声明的变量是局部变量，只能在块内部访问，外部无法访问

#### 1.5.2.2 函数作用域

函数作用域特点

1. 函数作用域也是局部作用域
2. 函数作用域在**函数调用**时产生，调用结束时销毁
3. 函数每次调用都会产生一个全新的函数作用域
4. 在函数中定义的变量是局部变量，只能在函数内部访问，外部无法访问

### 1.5.3 作用域链

作用域链特点

1. 当使用一个变量时
   + JS解释器会优先在当前作用域中寻找变量
   + 如果找到则直接使用，如果没找到则去上一层作用域中寻找，找到了则使用
   + 如果还是无法找到，则继续向上层寻找，以此类推
   + 如果直到全局作用域都没找到，则报错 xxx is not defined 

### 1.5.4 变量提升

+ 变量和函数的提升同时适用于函数作用域

#### 1.5.4.1 变量的提升

1. 使用var声明的变量，它会在所有代码执行前被声明(没用！！！)
   + 所以我们可以在变量声明前就访问变量
2. let声明的变量实际也会声明提前，但是在赋值之前解释器禁止访问该变量

#### 1.5.4.2 函数的提升

1. 使用**函数声明**创建的函数，会在其他代码执行前被创建
   + 所以我们可以在函数声明前调用函数

### 1.5.5 函数调用时的作用域

1. 函数的作用域，在函数创建时就已经确定了（词法作用域）
   + 和调用的位置无关！！！！！
   + 所以不管在哪里调用，函数在哪里创建作用域就在那儿

## 1.6 window对象

1. 浏览器中，浏览器为我们提供了一个window对象，可以直接访问
2. window对象代表的是浏览器窗口，通过该对象可以对浏览器窗口进行各种操作

   + 除此之外，window对象还负责存储JS中的内置对象和浏览器的宿主对象

     + 内置对象 如`window.String()`等等之类的直接可以使用的内置对象方法

     + 宿主对象 如`window.console.log()`之类的方法
3. window对象的属性可以通过window对象访问，也可以直接访问，window可以省略不写

   + 通过window寻找`window.console.log()`

   + 直接访问`console.log()`
4. 函数就可以认为是window对象的方法
5. 向window对象中添加的属性会自动成为全局变量
6. 使用function声明的函数，都会作为window的方法保存
7. window的全局变量优先级低于let定义的全局变量

## 1.7 立即执行函数（IIFE）

+ 立即执行函数是一个匿名函数，并且它只会调用一次
+ 可以利用IIFE来创建一个一次性的函数作用域，避免多人开发变量冲突问题

### 1.7.1 立即执行函数使用环境

在开发中尽量减少直接在全局作用域中编写代码！所以代码尽量要编写在局部作用域中

+ 使用let声明的变量，可以使用{}来创建块作用域，但是注意如果有var不行，var没有块作用域所以没用，但是var有函数作用域，可以利用函数作用域来隔离var的问题
  + 但是注意利用函数作用域隔离var，函数一定要调用，所以就需要立即执行函数来处理！

### 1.7.2 立即执行函数写法

+ 匿名函数会报错，应该function开头会被认为是函数声明会在代码执行前执行，执行完但是函数没有名无法使用所以会报错，所以可以在函数外部套上一个中括号不让函数以function开头，就不会被提前执行，也就不会报错

+ 并且套了中括号的函数会被当成一个函数对象，所以在函数后直接使用中括号可以立即调用函数，成为立即执行函数

+ 示例写法

  + ````````````````````javascript
    (function(){
         let a = 10
         console.log(a);
    })()
    ````````````````````

+ 注意！立即执行函数因为中括号的问题，两个立即执行函数在一起的中括号会被认为是在调用函数，所以会出现报错的情况，这就是一个JS自加结束分号位置判断错误。所以手动给立即执行函数加上分号表示代码结束位置即可！

## 1.8 this

+ 函数在执行时，JS解析器每次都会传递进一个隐含的参数
  + 这个参数就叫做this

+ 作用！在方法中调用方法的对象

### 1.8.1 函数中的this

+ this会指向一个对象，this所指向的对象会根据函数调用的方式不同出现不同
  1. 以函数形式调用时，this指向的是window
  2. 以方法的形式调用时，this指向的是调用方法的对象

### 1.8.2 箭头函数中的this

1. 箭头函数没有自己的this，它的this由外层作用域决定，箭头函数外层的this是谁，它的this就是谁
2. 箭头函数的this和它的调用方式无关
2. 箭头函数的this也无法通过call、apply和bind修改它的this

### 1.8.3 this所有情况

1. 以函数形式调用，this就是window
2. 以方法形式调用，this就是调用对象
3. 构造函数中，this就是新创建的实例对象
4. 箭头函数没有自己的this，由外层作用域决定
5. 通过call和apply调用的函数，它们的第一个参数就是函数的this
6. 通过bind返回的函数，this由bind一个参数决定（无法修改）

## 1.9 函数封装

+ 将一个方法作为函数封装起来，就不会只对一个数组或者对象起作用，函数封装起来，任何想使用该函数的对象或数组直接调用函数即可

+ 例子

  + 将选择排序作为函数封装，使所有需要排序的数组都可以使用

  + ``````````````javascript
    const arr = [9, 1, 3, 2, 8, 0, 5, 7, 6, 4]
    const arr2 = [9, 8, 5, 1, 3, 0, 2, 7, 6, 4]
    
            // 设置一个数组排序函数
    function arrSort(arr) {
        let arrFlag = arr.slice()
        for (let i = 0; i < arrFlag.length; i++) {
          for (let j = i + 1; j < arrFlag.length; j++) {
              if (arrFlag[i] > arrFlag[j]) {
              et temp = arrFlag[i]
              arrFlag[i] = arrFlag[j]
              arrFlag[j] = temp
          }
        }
    }
                // 排序完成将排完序的数组作为返回值返回
    return arrFlag
    }
    
    console.log(arr2);//[9, 8, 5, 1, 3, 0, 2, 7, 6, 4]
    console.log(arr);//[9, 1, 3, 2, 8, 0, 5, 7, 6, 4]
    console.log(arrSort(arr));//[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    console.log(arrSort(arr2));//[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    ``````````````

## 1.10 高阶函数

+ 如果一个函数的参数或者返回值是函数，则这个函数就称为高阶函数

+ `inspectAgeMid18`就是一个高阶函数

+ 参数是函数的高阶函数

  + ```````javascript
        // 过滤出符合条件的对象
            function inspectAgeMid18(personArr , cb){
                let newArrey = []
                for (let i = 0; i < personArr.length; i++) {
                    if (cb(personArr[i])) {
                        newArrey.push(personArr[i])
                    }
                }
                return newArrey
            }
            console.log(inspectAgeMid18(personArr , a => a.age < 18 ));
            console.log(inspectAgeMid18(personArr , a => a.age >= 18 ));
    
            const arr = [1,2,3,4,5,6,7,8,9,10]
            let result = inspectAgeMid18(arr , a => a % 2 === 0)
            console.log(result);
    ```````

+ 返回值为函数的高阶函数

  + ````````javascript
            function someFn(){
                return 'hello'
            }
            function outer(cb){
                console.log(cb);
                return () => {
                    console.log('记录日志');
                   const result =  cb()
                   return result
                }
            }
          
            let result = outer(someFn)
            console.log(result()); // 记录日志 hello
        ````````

## 1.11 闭包

+ 可以利用函数隐藏不希望被外部访问到的变量
+ 闭包就是能访问外部函数作用域中变量的函数

### 1.11.1 什么时候使用闭包

+ 当我们需要隐藏一些不希望被别人访问的内容时就可以使用闭包

### 1.11.2 构成闭包的要件

1. 函数的嵌套
2. 内部函数要引用外部函数中的变量
3. 内部函数要作为返回值返回

### 1.11.3 闭包的原理

1. 闭包的原理就是利用（词法作用域）函数在哪里声明作用域就在那

### 1.11.4 闭包的生命周期

1. 闭包在外部函数调用时产生，外部函数每次调用都会产生一个全新的闭包
2. 在内部函数丢失时销毁，返回值变量被覆盖（内部函数被垃圾回收了，闭包才会消失）

### 1.11.5 闭包的注意事项

+ 闭包主要是用来隐藏一些不希望被外部访问到的内容
  + 这就意味着闭包需要占用一定的内存空间
+ 相较于类来说，闭包比较浪费内存空间（类可以使用原型而闭包不能）
  + 需要执行次数较少时使用闭包
  + 需要大量创建时使用类

## 1.12 递归(遗留问题！)

+ 调用自身的函数称为递归函数
+ **递归的作用**和循环是基本一致的，不同点是，递归的思路比较清晰简洁，循环的执行性能比较好
  + 开发中一般的问题都可以通过循环解决，尽量去使用循环，少用递归，只在一些使用循环解决比较麻烦的情况下，才使用递归
+ 递归的核心思想就是将一个大问题拆分成一个个小问题，小问题解决了大问题也就解决了

### 1.12.1 递归的创建要件

1. 基线条件 — 递归的终止条件
2. 递归条件 — 如何对问题进行拆分

### 1.12.2 递归实例（阶乘）

+ ````javascript
           function jieCheng2(num){
        
              // 基线条件
              if(num === 1){
                  return 1
              }
        
              // 递归条件
              return jieCheng2(num-1) * num
           }
           console.log(jieCheng2(5));
          //  jieCheng2(5)
          /*
          第一次执行的返回值 jieCheng2(4) * 5
          第二次执行的返回值 jieCheng2(3) * 4
          第三次执行的返回值 jieCheng2(2) * 3 
          第四次执行的返回值 jieCheng2(1)返回值1 * 2
          第五次执行的返回值 jieCheng2(1) = 1 第五次结束递归 拿到		 返回值开始进行计算
          */
  ````

1.12.3 递归实例（斐波那契额数列）

+ ````javascript
          /*
              一对兔子出生后的两个月后，每个月都能生一对小兔子
              -  编写一个函数，用来计算第N个月的兔子数量
        
              1 2 3 4 5 6 7  8  9  10 11 12
              1 1 2 3 5 8 13 21 34 ...
        
              - 规律 当前数等于前两个数之和（斐波那契数列）
          */
        
          function fn(n){
              // 基线
              if( n < 3){
                  return 1
              }
              // 递归
              return fn(n-1) + fn(n-2)
          }
        
          console.log(fn(4));
      ````

## 1.13 隐含参数

### 1.13.1 `this` 

+ this也是函数中的一种隐含参数
+ this详细的学习笔记在1.8this中

### 1.13.2 `arguments`

+ `arguments`是函数中又一个隐含参数
+ `arguments`是一个类数组对象（伪数组）
  + 类数组对象介绍
    + 和数组相似，可以通过索引来读取元素，也可以通过for循环、for-of遍历，但是它不是一个数组对象，不能调用数组的方法
+ 注意！**箭头函数中没有`arguments`**

#### 1.13.2.1 基础作用

+ `arguments`用来存储函数的实参，无论用户是否定义形参，实参都会存储到`arguments`类数组对象（隐含参数）中，可以通过该对象直接访问实参

#### 1.13.2.2  实际场景作用

+ 通过`arguments`，可以不受参数数量的限制更灵活的创建函数

+ ````````````````javascript
  		 function sum(){
           // 通过arguments，可以不受参数数量的限制更灵活的创建函数
              let flag = 0
              for(let i = 0;i < arguments.length;i++){
                  flag += arguments[i]
              }
              return flag
          }
          
          let result = sum(1,5,9,66)
          console.log(result); // 81
  ````````````````

#### 1.13.2.3 `arguments`缺点

1. 不是自己定义的根本不会使用
2. 伪数组不是数组，用不了数组方法导致一些麻烦问题

解决方案！JS函数特意给了我们一个可变参数来代替使用`arguments`

### 1.13.3 可变参数

+ 可变参数，在定义函数时可以将参数指定为可变参数
+ 可变参数与`arguments`相比主用可变参数，`arguments`比较老了会出现一些问题，可变参数的出现主要就是用来完善且代替`arguments`的

#### 1.13.3.1 可变参数定义方法

+ 通过在形参区域使用`...可变参数名`来定义可变参数

+ ```javascript
          function sum2(...num){
              return num.reduce((a,b) => a + b,0)
          }

#### 1.13.3.2 可变参数作用

1. 可变参数可以接收任意数量实参，并将它们统一存储到一个数组中返回

2. 可变参数的作用和`arguments`基本是一致的，但是也具有一些不同点

   1. 可变参数的名字可以自己指定

   2. 可变参数就是一个数组，可以直接使用数组的方法

   3. 可变参数可以配合其他参数一起使用

      + `arguments`和参数间会有重复数据，但是可变参数不会拿取其他定义了形参的数据内容，只会拿到剩下没有定义参数的内容

      + ````javascript
                function fn1(a,b,...c){
                    console.log(a);
                    console.log(b);
                    console.log(c);
                }
                fn1(1,2,3) // 1 2 [3]
        ````

      + 注意！当可变参数和普通参数一起使用时，需要将可变参数写到最后

## 1.14 函数的方法

+ 函数除了通过`函数()`这种形式调用外，函数也是一种对象，函数的原型中也有函数的方法，所以也可以通过函数方法的形式调用函数

### 1.14.1 函数方法

#### 1.14.1.1 `call`、`apply`

+ 除了通过`函数()`调用函数，还可以通过 `call`、`apply`来调用函数，并且通过 `call`、`apply`调用的函数还可以指定函数中的this

+ `call`的参数

  1. call第一个参数，将会成为函数的`this`，**无法修改箭头函数的this**

  2. 调用call方法调用函数，函数的实参直接在第一个参数后一个一个列出来

     + ````````javascript
               function fn(a,b){
                   console.log(a , b , this);
               }
             
               let obj = {
                   name:'孙悟空'
               }
             
               fn.call(obj,1,2) //1 2 {name: '孙悟空'}
       ````````

+ `apply`的参数

  1. apply第一个参数，将会成为函数的`this`，**无法修改箭头函数的this**

  2. 通过apply方法调用函数，函数的实参需要通过一个数组传递

     + `````````javascript
               function fn(a,b){
                   console.log(a , b , this);
               }
             
               let obj = {
                   name:'孙悟空'
               }
             
               fn.apply(obj,[1,2]) // 1 2 {name: '孙悟空'}
       `````````

#### 1.14.1.2 `bind`

+ `bind()`是函数的方法，可以用来创建一个新的函数
+ 不是破坏性方法，不会破坏调用的函数对象本身
+ 作用
  + `bind`可以为新函数绑定this，**无法修改箭头函数的this**
  + 也可以为新函数绑定参数
+ 参数
  1. 为新函数绑定的this
  2. 从第二个参数开始就可以传递新函数中需要的实参，一个一个传递 ，但是注意！**用bind方法传递的实参是锁死的无法修改**，最好还是通过返回值得到新函数，执行新函数时再指定实参

## 1.15 函数执行环境

+ 函数在每次执行时，都会产生一个执行环境

  + 执行环境负责存储函数执行时产生的一切数据

### 1.15.1 函数的执行环境要存储到哪里呢？

  + 函数的执行环境存储到了一个叫做调用**栈**的地方

### 1.15.2 栈

+ 栈，是一种数据结构
+ 栈中最上面的数据称为栈顶
  + 特点：
    + 后进先出（越早的数据越在下层）

### 1.15.3 队列

+ 队列，是一种数据结构
  + 特点：
    + 先进先出（越早排队越早离开）

### 1.15.4 调用栈（call stack）

+ 调用栈负责存储函数的执行环境
+ 当一个函数被调用时，它的执行环境会作为一个栈帧插入到调用栈的栈顶，函数执行完毕其栈帧会自动从栈中弹出
+ ![1](D:\学习\超哥JS核心基础\学习源码+笔记\06.函数\img\1.png)

### 1.15.5 消息队列

+ 消息队列负责存储将要执行的函数
+ 当我们触发了一个事件时，其响应函数并不是直接添加到调用栈中的
  + 因为调用栈中有可能存在一些还没有执行完的代码
+ 事件触发后，JS引擎将事件响应函数插入到消息队列中排队
+ ![2](D:\学习\超哥JS核心基础\学习源码+笔记\06.函数\img\2.png)



















