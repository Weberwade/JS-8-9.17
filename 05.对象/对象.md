# 一、对象

对象是JS中的一个复合数据类型，它相当于一个容器，在对象中可以存储各种不同类型数据

## 1.1数据类型

数据类型分为两种原始值和对象

### 1.1.1 原始值

+ 原始值只能用来表示一些简单的数据，不能表示复杂数据

原始值包括以下七个，其余的数据都是对象

1. 数值 Number
2. 大整数 BigInt
3. 字符串 String
4. 布尔值 Boolean
5. null（空值）
6. undefined（未定义）
7. 符号 Symbol

### 1.1.2 对象

+ 对象是JS中的一个复合数据类型，它相当于一个容器，在对象中可以存储各种不同类型数据

## 1.2 创建对象

### 1.2.1 使用new创建对象及增删改查

+ 一个复杂的方式，但是结构清晰
+ 创建对象语法：
  + 使用` let 变量名 = new Object()`创建一个对象，并赋值给一个变量，让变量成为一个对象类型的数据

### 1.2.2 对象字面量方式创建

+ 可以直接使用{} 来创建对象

+ 使用{}所创建的对象，可以直接向对象中添加属性

  + 使用`属性名:属性值`添加，多个属性之间逗号隔开

  + 也可以使用[]添加需要特殊属性名的属性,`['15932789']:niu`

    + 语法： [特殊属性名或变量]:属性值

  + ````````javascript
    let obj = {
       name:'悟空',
       age:18,
       gender:'男'
       ['15932789']:niu
    }

## 1.3 对象增删改查

### 1.3.1 对象中添加属性语法

+ `对象.属性名 = 属性值`
  + 使用.运算符添加，属性名只能是一个正常的字符串
+ `对象[属性名] = 属性值`
  + 使用[]运算符添加，属性名可以是一个变量，或一个很奇怪的字符串
+ 可以使用同样的方法为同样的属性名赋值，覆盖之前对象中属性名的值

### 1.3.2 读取对象中的属性

+ 对象.属性名
+ 对象[属性名]

### 1.3.3 删除属性

+ delete 对象.属性名 
+ 读取删除的内容会返回undefined

+ 实例

  + `````javascript
    // 使用new创建一个对象
    let people = new Object()
    
    // 为对象中添加内容
    people.name = '孙悟空'
    people.age = 18
    
    //读取内容
    console.log(people.name);
    
    //删除对象
    delete people.name //读取删除的内容会返回undefined
    `````

### 1.3.4 检查对象属性名是否存在

+ in运算符
  + 用来检查对象中识符含有某个属性
  + 语法 属性名 in 对象名 `name in obj`
  + 如果属性存在则返回true
  + 如果属性不存在则返回false

## 1.4 对象的规范

### 1.4.1 属性名规范

+ 通常属性名就是一个字符串，所以属性名可以是任何值，没有什么特殊要求

  + 但是属性名太特殊了，不能直接使用，需要使用[]来设置
  + 例如`obj['1595654dasd'] = 'kong'`，获取数据也要使用中括号的方法获取，但是不建议使用太bt了
  + 虽然可以随意取名，但是我们还是强烈建议属性名也按照标识符的规范命名，建议使用驼峰命名法

+ 还可以使用符号（Symbol）作为属性名，来添加属性

  + 使用中括号添加

  + 例如

    + `````javascript
      let mySymbol = Symbol() 
      obj[mySymbol] = 'shux'
      console.log(mySymbol);
      `````

  + 获取属性值时也要使用中括号

    + `    console.log(obj[mySymbol]);`

  + 使用symbol添加的属性，通常是那些不希望被外界访问的属性

+ 使用[]操作属性名时，可以用变量

  + 例如

    + ``````javascript
      let str = 'address'
      obj[str] = '花果山'
      console.log(obj); // address:'花果山'
      ``````

  + 如果变量是同样的值，使用其他变量就可以取到对象中的值

    + ```````javascript
      let str = 'address'
      let per = 'address'
      obj[str] = '花果山'
      console.log(obj[per]); // '花果山'

### 1.4.2 属性值规范

+ 对象的属性值可以是任意的数据类型，也可以是一个对象

  + 例如

    + ``````javascript
      let obj = new Object()
      obj.f = Object()
      obj.f.str = '123'   
      console.log(obj.f.str); // '123'

## 1.5 对象枚举属性

枚举属性，指将对象中的所有的属性全部获取

+ 使用for-in语句

  + 语法

    + `````javascript
      for(let propName in 对象){
          语法...
      }
      `````

  + for-in的循环体会执行多次，有几个属性就会执行几次

    + 每次执行时，都会将一个属性名赋值给我们for-in中间定义的变量
    + 因为是一个变量，所以我们可以使用`对象[变量名]`的方式获取对象中的每一个属性，拿上面语法区举例`对象[propName]`

+ 注意！不是所有的属性都可以枚举
  + 比如
    + 使用符号添加的属性

## 1.6 对象可变类型

+ 原始值都属于不可变类型，一旦创建就不无法修改，内存中不会创建重复的原始值
+ 对象属于可变类型
  + 对象创建完成后，可以任意的添加修改删除对象中的属性
+ 对象内存模式
  + 原始值的值都是内存地址，内存地址内的内容无法修改，只会指向新的内存地址，所以是不可变类型
  + 对象内存地址中的数据是可以变动的如属性可以随意修改，可以随意添加删除属性，所以对象是可变类型，但是注意属性值不是直接存储也是开辟新的内存地址进行存储，属性值也是指向的内容的内存地址
  + ![image-20220816183704024](D:\学习\超哥JS核心基础\学习源码+笔记\05.对象\img\image-20220816183704024.png)
+ 注意事项！
  + 当对两个对象进行相等或者全等比较时，比较的是对象的内存地址
    + 内存地址相同则返回true
    + 内存地址不相同返回false
  + 如果有两个变量同时指向一个对象，通过一个变量修改对象时，对另外一个变量也会产生影响!
  + 使用变量存储对象时，很容易因为改变变量指向的对象，提高代码复杂程度
    + 所以通常情况下，声明储存对象的变量时会使用const
    + 注意！const只是禁止变量重新修改内存地址，不会影响对对象的修改，应该对象修改的是内存地址内的内容const管不着

## 1.7 对象方法

### 1.7.1 方法（method）

+ 当一个对象的属性指向一个函数时，那么我们就称整个函数是该对象的方法，调用函数就称为调用对象的方法

+ `````````javascript
          let obj = {
              fn1:function(){
                  console.log('我是fn1');
              },
          }
          
          obj.fn = function(){
              console.log('我是fn');
          }
          console.log(obj.fn1);
          obj.fn1() // 我是fn1
          obj.fn() // 我是fn
      `````````

## 1.8 window对象

1. 浏览器中，浏览器为我们提供了一个window对象，可以直接访问
2. window对象代表的是浏览器窗口，通过该对象可以对浏览器窗口进行各种操作

   + 除此之外，window对象还负责存储JS中的内置对象和浏览器的宿主对象

     + 内置对象 如`window.String()`等等之类的直接可以使用的内置对象方法

     + 宿主对象 如`window.console.log()`之类的方法
3. window对象的属性可以通过window对象访问，也可以直接访问，window可以省略不写

   + 通过window寻找`window.console.log()`

   + 直接访问`console.log()`
4. 函数就可以认为是window对象的方法
5. 向window对象中添加的属性会自动成为全局变量
6. 使用function声明的函数，都会作为window的方法保存
7. window的全局变量优先级低于let定义的全局变量

## 1.9 使用Obejct创建对象的问题

+ 使用Obejct函数或简写方法创建的对象都由一些瑕疵
  1. 无法区分出不同类型的对象
  2. 不方便批量创建对象
+ 在JS中可以通过类（class）来解决以上问题：
  1. 类是创建对象模板，可以将对象中的属性和方法直接定义在类中
     + 定义后，可以直接通过类来创建对象

## 1.10 对象的复制

### 1.10.1 使用`Object.assign()`方法进行浅拷贝

+ 将被拷贝对象中的属性复制到目标对象里，并将目标对象作为返回值返回

+ 如果目标对象中有属性，只要属性名不相同，也不会被被复制对象修改，或者删除，但是属性名相同会被被复制对象中的属性覆盖

+ 参数

  1. 目标对象（复制对象）
  2. 被复制对象

+ ````````````javascript
  const obj = {name:'孙悟空',age:18}
  const obj2 = Object.assign({} , obj)
  console.log(obj2); // {name: '孙悟空', age: 18}
  console.log(obj2 === obj); // false
  ````````````

### 1.10.2 使用`...`展开运算符浅拷贝对象

+ 在对象中使用`...被复制的对象名`浅拷贝一个对象

+ 如果展开运算符中有同样的属性，那么永远都是后面会覆盖前面的，后面的优先级更高

+ ````````````javascript
  const obj = {name:'孙悟空',age:18}
  const obj2 = {...obj}
  console.log(obj2); // {name: '孙悟空', age: 18}
  console.log(obj2 === obj); // false

### 1.10.3 可以利用JSON深复制对象

+ 详情见 09.内建对象 -> JSON中的详解

### 1.10.4 `structuredClone()`深复制对象

+ 使用`structuredClone()`函数可以对一个数组或对象进行深复制，将复制的对象作为函数返回值返回

+ 参数

  + 需要被深复制的对象

+ 语法

  + `const 新对象名 = structuredClone( 被深复制的对象 ) `

+ ```````````javascript
  const obj3 = structuredClone(obj)

