# 面向对象

## 一、面向对象编程（OOP）介绍

1. 程序是干嘛的？

   + 程序就是对现实世界的抽象（照片就是对人的抽象）（对象就是对事物的抽象）

2. 对象是干嘛的？

      + 一个事物抽象到程序中后就变成了对象

      + 在程序世界中，一切皆对象
      + 对象就是事物的抽象，例如一个人放到程序中设置了部分信息就是抽象，如果有完整的意识那才是具体

3. 对象的组成

   + 一个对象由两部分组成：属性和方法
     + 例如一个事物通常由两个部分组成：数据和功能
     + 事物的数据到了对象中，体现为属性
     + 事物的功能到了对象中，体现为方法

4. 面向对象的编程

   + 面向对象的编程指，程序中的所有操作都是通过对象来完成
   + 做任何事情之前都需要先找到它的对象，然后通过对象来完成各种操作

## 二、类

### 2.1 类的使用场景

使用Obejct创建对象的问题

+ 使用Obejct函数或简写方法创建的对象都有一些瑕疵
  1. 无法区分出不同类型的对象
  2. 不方便批量创建对象
+ 在JS中可以通过类（class）来解决以上问题：
  1. 类是创建对象模板，可以将对象中的属性和方法直接定义在类中
     + 定义后，可以直接通过类来创建对象
  2. 通过同一个类创建的对象，我们称为同类对象
     + 可以使用`instanceOf`来检查一个对象是由某个类创建的
       + `instanceOf`语法 `对象名 instanceOf 类名` 
       + 实例`console.log(p1 instanceof Person);`
     + 如果某个对象是由某个类创建，则我们称该对象是这个类的实例

### 2.2 创建类语法

2.2.1 类声明

+ `class 类名 {}` 类名要使用大驼峰命名

示例

+ ``````````````javascript
  class Person{}
  ``````````````

2.2.2 类表达式

+ `let 类名 = class {}`

实例

+ `````````````````javascript
  let Person = class {}

### 2.3 通过类创建对象

语法

+ `const 对象名 = new 类()`调用构造函数创建对象

+ 等于类代替了Object成为对象的统称，即通过类调用，即是这个类的对象

### 2.4 类的创建步骤

1. 类是创建对象的模板，要创建第一件事就是定义类

   + `class Person {}`

2. 类代码块中设置对象属性

   + 要设置类对象中应该有什么属性，直接在类代码块中定义

   + 直接添加在类中的属性叫做实例属性，实例属性通过类的实例访问

   + 还可以在类代码块中通过`static`添加静态属性，静态属性实例无法访问，只有类可以访问，也可以称为类属性

     + ````````javascript
               class Person {
                   name = '悟空'
                   age = 18
                   static hh = 1
               }
               const p1 = new Person()
               console.log(p1); // Person{name:'悟空',age:18}
             		console.log(p1.hh) //undefined
             		console.log(Person.hh); // 1

   + 注意！

     + 类的代码块是用来设置对象的属性的，不是什么代码都可以写
     + 类的代码块默认就是严格模式
     + 类代码块更像作用域，而不是对象代码块，用=赋值，切不需要逗号隔开（自动添加分号）
     
   + 特点！

     + 如果我们在类中直接指定实例属性的值时，意味着我们创建的所有对象的属性都是这个值

3. 类代码块中设置对象方法

+ 实例方法的添加方式

     + 方法一：函数表达式的方式，在打印类实例对象时可以看见实例方法的存在
     
     + 方法二：对象中对于函数表达式的简写属性`sayHello(){}`，在打印类实例对象时看不见实例方法的存在，但是可以调用
     
       + 实例方法中的this就是当前实例
     
     + 示例
     
       + ````````````````javascript
         class Person {
              name = '孙悟空'
              sayHello(){
              console.log('sss');
              } // 实例方法 ，实例方法的this就是当前实例
         }
                
         let p1 = new Person()
         console.log(p1);

+ 静态方法的添加方式（类方法）

  + 静态方法（类方法）只能通过类对象来调用，实例对象无法调用

  + 方法一：`static 方法名(){语句...}`只有类对象可以调用

    + 静态方法的this，指向的是当前类
    
  + 示例
  
    + ``````````````javascript
              class Person {
                  name = '孙悟空'
                  // 创建静态方法
                  static a(){
                      console.log('a');
                  } // 静态方法的this，指向的是当前类
              }
            
              let p1 = new Person()
              console.log(Person.a());
      ``````````````
  
+ **类中的特殊方法constructor(重点！！！)**

  + 该方法我们称为构造函数（构造方法），构造函数会在我们调用类创建对象时执行

  + 调用`new Person()`时就等于调用构造函数`constructor`方法,并且Person()的参数会传递给构造函数constructor方法中

  + 我们利用构造函数，为实例属性进行赋值

  + 在构造函数中，this表示当前所创建的实例对象

  + 示例

    + ```````````````javascript
          class Person {
              constructor(name , age , gender){
                  this.name = name
                  this.age = age
                  this.gender = gender
              }
          }
      
          let p1 = new Person('孙悟空',18,'男')
          console.log(p1); 
      	// Person{name:'孙悟空',age:18,gender:'男'}
      ```````````````

### 2.5 类检查语句

#### 2.5.1 instenceof 

+ 作用
  + 检查一个对象是否是一个类的实例对象

+ 语法
  + `instanceOf`语法 `对象名 instanceOf 类名` 
  + 实例`console.log(p1 instanceof Person);`
+ 特性
  + instanceof检查的是对象的原型链上是否有该类实例
    + 只要原型链中存在该实例就会返回true
    + Object是所有对象的原型，所以任何对象和Object进行instanceof运算都会返回true

#### 2.5.2 in运算符扩展

+ 作用
  + 检查一个对象自身或原型中是否存在一个属性
+ 语法
  + `属性名 in 对象名`注意！属性名一般是字符串
  + `'sayHello' in p`
+ 特性
  + in运算符检查属性时，无论属性是在对象自身还是在原型中，都会返回true

#### 2.5.3 hasOwnProperty（不推荐使用）

+ 作用
  + 检查一个对象的自身是否存在检查的属性，但是是作为对象的方法使用，有返回`true`没有返回`false`
+ 语法
  + `对象名.hasOwnProperty(属性名)`注意！属性名一般是字符串
  + `p.hasOwnProperty('name')`
+ 特性
  + 只检查对象自身中是否存在检查属性，不检查原型中是否存在

#### 2.5.4 hasOwn（新方法）

+ 作用
  + 代替`hasOwnProperty`的新方法，检查一个对象的自身是否存在检查的属性，但是是作为Object的方法调用，有返回`true`没有返回`false`
+ 语法
  + `Object.hasOwn(对象名,属性名)`注意！属性名一般是字符串
  + `Object.hasOwn(p , 'name')`
+ 特性
  + 用类实例直接调用，解决了无原型对象因为没有`Object`原型找不到`hasOwnProperty`的问题

## 三、面向对象编程的特点

面向对象编程的特点介绍

1. 封装 — 安全性
2. 继承 — 扩展性
3. 多态 — 灵活性

### 3.1 封装

#### 3.1.1 封装介绍

1. 对象就是一个用来储存不同属性的容器 （装）
2. 对象不仅负责存储属性，还要负责数据的安全（封）

+ 直接添加到对象中的属性并不安全，因为它们可以被任意的修改

#### 3.1.2 如果确保数据安全

1. 私有化数据

   + 实例属性使用#开头就变成了私有属性
   + #开头的属性一定要在类内部先声明不赋值都可以，直接在constructor方法中添加会报错
   + 私有属性只能在类内部访问
   + 将需要保护的数据设置为私有，只能在类内部使用

2. 提供setter和getter方法来开放对数据的操作

   + 私有化属性外部不能直接访问，但是我们可以在类中添加方法让外部间接访问到私有化属性进行操作

   + **属性设置为私有，通过getter setter方法操作属性带来的好处**

     1. 可以控制属性的读写权限
     2. 可以在方法中对属性的值进行验证

   + JS中提供了get和set关键字，让我们简单的设置改写或读取私有属性的方法，并且读取的时候还是用对象的方式进行读取

     + 例如:

     + ``````````````````````javascript
       // 读取私有属性
       get gender(){
           return this.#gender
       }
       // 直接 实例对象名.gender 就能获取属性
       
       // 修改私有属性
       set gender(gender){
           this.#gender = gender
       }
       // 直接 实例对象名.gender = 新值 就能修改属性
       ``````````````````````

#### 3.1.3 封装总结

1. 封装主要用来保证数据的安全

2. 实现封装的方法

   1. 属性私有化 使用#

   2. 通过JS提供的getter和setter方法来操作属性

      + ``````````````javascript
        // 获取封装的属性，get关键字
        get 需要获取的私有属性名(){
            return this.#属性
        }
        
        // 修改封装的属性，set关键字
        set 需要修改的私有属性名(参数){
            this.#属性 = 参数
        }

### 3.2 多态

1. 在JS中不会检查参数的类型，所以这就意味着任何数据都可以作为参数传递
2. 要调用某个函数，无需指定的数据类型，只要对象满足使用条件即可使用
3. 多态为我们提供了灵活性

#### 3.2.1 多态总结

JS不限定你的形态，不管你是什么类型，你都可以进行传递，只要你有我需要的内容你就可以使用

### 3.3 继承

#### 3.3.1 继承作用及特点

1. 可以通过extends关键字来完成继承，当一个类继承另一个类时，就相当于将另一个类中的代码复制到了当前类中（简单理解）
2. 继承发生时，被继承的类称为**父类（超类）**，继承的类称为**子类**
   + 子类中，可以通过创建同名方法来重写父类的方法
   + 注意！重写构造函数时，构造函数的第一行代码必须为`super()`表示调用父类的构造函数，不写`super()`没有父元素给过来的实例，代码会报错
3. 通过继承可以减少重复代码，并且可以在不修改一个类的前提对其进行扩展

#### 3.3.2 继承语法特点

1. 使用extends来继承类

   + ````````javascript
     class Dog extends Animal{
                 
     }
     // Dog继承Animal类中的所有代码 Dog为子类 Animal为父类
     ````````

2. 重写构造函数时，构造函数的第一行代码必须为`super()`表示调用父类的构造函数，如果不写`super()`代码会报错,想使用父类的构造函数方法，记得将`constructor`中的参数传递到super中，父类的构造函数才能获取到参数

   + `````````````````javascript
     class Dog extends Animal{
           constructor(name){
           super(name)
        } 
     }
     const dog = new Dog('旺财')
     console.log(dog);
     `````````````````

3. `super`就等于是在子类中的父类对象，可以用`super()`调用构造函数，或用`super.属性名`或`super.方法名`来调用父类中的属性或方法

   + `````````````````````javascript
     sayHello(){
        super.sayHello()
        console.log('wangwang');
     }
     // 在sayHello中调用了父类的sayHello方法
     `````````````````````

#### 3.3.3 继承主要作用

+ 通过继承可以在不修改一个类的情况下对其进行扩展
+ OCP 开闭原则
  + 程序应该对修改关闭，对扩展开放

#### 3.3.4 继承的实现方法

1. 当继承时，子类的原型就是父类的实例

## 四、对象的内存结构

### 4.1 对象内存结构图

![1](D:\学习\超哥JS核心基础\学习源码+笔记\07.面向对象\img\1.png)

### 4.2 对象内存位置（包含原型）

#### 4.2.1 对象自身内部

1. 直接通过对象所添加的属性，属性位于对象自身中
2. 在类中通过 x = y 的形式添加的属性，属性位于对象自身中

#### 4.2.2 原型对象（prototype）

##### 4.2.2.1 原型介绍作用及基础理念

**基础介绍**

+ 对象中还有一些内容，会存储到其他的对象里（原型对象）

+ 在对象中会有一个属性专门用来存储原型对象，这个属性叫做`__proto__`
+ 原型对象也负责为对象存储属性：
  + 当我们访问对象属性时，会**优先访问对象自身内部**
  + 当对象自身内部不包含该属性时，**才会去原型对象中寻找**

**原型作用**

1. 原型就相当于是一个公共的区域，可以被所有该类实例对象访问，所以可以将该类实例对象的所有公共属性、方法，统一存储到原型中
   + 这样我们只需要创建一个属性、方法，即可被所有实例访问
   + 对象中有些值是对象独有的，像(name,age,gender)，但有一些值对于所有实例对象来说都是一样的，像对象中的方法，对于一样的值没必要重复创建（所以原型中一般都存储公共方法 ）

**基础理念**

1. 所有的同类对象它们的原型对象都是同一个，也就意味着同类的原型链也是一样的

##### 4.2.2.2 属性怎么添加到原型中？

属性方法添加到原型中的两种情况

1. 在类中通过`xxx(){}`添加的方法，位于原型中
2. 主动向原型中添加的属性或方法

##### 4.2.2.3 如何访问原型对象

不标准的访问方法，修改原型内容会出问题，可以访问，但是不要使用这个方法修改原型中的内容

+ `对象名.__proto__`

###### 4.2.2.3.1 标准的原型对象访问方法

标准的访问对象中原型对象的方法

+ 使用Object中的getPrototypeOf()方法`Object.getPrototypeOf(对象名)`

##### 4.2.2.4 原型对象中的数据内容

原型中的数据分为两大块

1. 对象中要使用的数据（属性、方法等）
2. constructor（对象的构造函数、就是创建构造函数的类、反向理解可以通过constructor构造函数得知对象是调用那一个类创建的）

**注意！**原型对象中也有原型对象，这样就构成了一条原型链，根据对象的复杂程度不同，原型链的长度也不同

##### 4.2.2.5 原型链

+ 作用域和原型链的区别
  + 作用域链是找变量的链，找不到则报错
  + 原型链是找属性或方法的链，没有则返回undefined

+ 原型对象中也有原型对象，这样就构成了一条原型链，根据对象的复杂程度不同，原型链的长度也不同

实例

+ ``````javascript
          class Person {
              name = '孙悟空'
        
              sayHello = function () {
                  console.log('我是对象自身中');
              }
              sayHello() {
                  console.log('我在原型链中' + this.name);
              }
          }
        
          const p = new Person()
        
          console.log(Object.getPrototypeOf(p));
        		// p对象的原型链：p对象 --> __proto__ --> __proto__ 
        		// -->null
  ``````

+ ````````````javascript
  		const obj = {}
    		// obj对象的原型链: obj对象 -->  __proto__ --> null
  ````````````

###### 4.2.2.5.1 原型链读取顺序

+ 读取对象属性时，会优先读取对象自身属性
  + 有则使用，没有则去对象原型中寻找
  + 原型中有则使用，没有则去原型的原型中寻找
  + 直到找到Object对象的原型，Object的原型为null，依然没找到则返回undefined

##### 4.2.2.5 修改原型

**大部分情况下，我们是不需要修改原型对象的**

**不要使用的方法！！！！**

+ 通过对象找到原型修改原型，向原型中添加方法，修改后所有同类实例都能访问该方法。注意！**千万不要通过此说法修改实例对象原型！！！**

  + ````````````javascript
            class Person{
                name = '孙悟空'
                age = 18
          
                sayHello(){
                    console.log('Hello,我是',this.name);
                }
            }
          
            const p = new Person()
            const p2 = new Person()
          
            
            p2.__proto__.run = () => {
                console.log('我出来了');
            }
          
            p.run() // 我出来了
          		
    ````````````

  + **千万不要通过类的实例去修改原型！！！！！！！！**

  + 原因

    1. 通过一个对象影响所有同类对象，这么做不合适
    2. 修改原型先得创建实例，麻烦
    3. 可以直接赋值修改掉原型对象，危险！

**正常修改方法**

+ 我们可以通过类的`prototype`属性，来访问实例的原型

  + `类名.prototype` 定位到此类所有实例对象的原型
  + 相当于通过类找到所有实例对象的原型，其实就是类本身

+ 修改原型时，最好通过类去修改

  + `````````````javascript
            class Person{
                name = '孙悟空'
                age = 18
          
                sayHello(){
                    console.log('Hello,我是',this.name);
                }
            }
            Person.prototype.fly = () => {
                console.log('我在飞');
            }

  + 好处

    1. 一修改就是修改所有实例对象的原型
    2. 无需创建实例即可完成对类的修改

##### 4.2.2.6 原型的原则

1. 原型尽量不要手动改
2. 要改也不要通过实例对象改
3. 通过类.prototype属性去修改
4. 最好不要直接给prototype去赋值

## 五、旧类

### 5.1 旧类的定义及特性

早期的JS中，直接通过函数来定义类

+ 一个函数如果直接调用 xxx() 那么这个函数就是一个普通函数
+ 一个函数如果通过new调用 new xxx() 那么这个函数就是一个构造函数

+ **定义方法**

  + `````````````javascript
    // 创建了一个Person类 这个写法等价于 class Person{}
    function Person(){
    
    }
    `````````````

+ 继承方法

  + `````` javascript
    // 直接将原型变成需要继承类的实例对象
            const Animal = (function(){
                function Animal() {
                    
                }
    
                return Animal
            })()
            const Cat = (function(){
                function Cat() {
                    
                }
    
                Cat.prototype = new Animal()
    
                return Cat
            })()    

+ 调用方法

  + `````javascript
    conts p = new Person() //创建一个Person类实例
    `````

+ 特性

  + 这种写法称为构造函数，`constructor`本身就是构造函数，所以可以省去直接向构造函数传参，构造函数this代表实例对象

+ 缺点

  + 代码太散，需要用闭包包起来，麻烦

## 六、new运算符

new运算符是创建对象时要使用的运算符

[new 运算符 - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new#描述)MDN文档地址

### 6.1 new关键字创建过程

+ 当使用new去调用一个函数时，这个函数会作为构造函数调用

1. 创建一个普通的JS对象(Object对象**`{}`**)，为了方便，称其为新对象
2. 将构造函数的`prototype`属性设置为新对象的原型
3. 使用实参来执行构造函数，并且将新对象设置为函数中的**`this`**
4. 如果构造函数返回的是一个非原始值，则该值会作为**`new运算`**的返回值返回**(千万别这么做！)**，如果构造函数的返回值是一个原始值或没有指定返回值，则新对象将会作为返回值返回
   + 通常不会为构造函数指定返回值！

+ **注意！这是构造函数的创建流程，所以新类是指`constructor`中的流程**

## 七、面向对象总结

### 7.1 面向对象本质

面向对象的本质就是，编写代码时所有的操作都是通过对象来进行的

### 7.2 面向对象编程步骤

1. 找对象
2. 搞对象

### 7.3 怎么学习对象

1. 明确这个对象代表什么，有什么用
2. 如何获取到这个对象
3. 如何使用这个对象(对象中的属性和方法)

### 7.4 对象的分类

1. 内建对象
   + 由ES标准所定义的对象
   + 如`Obejct`、`Function`...
2. 宿主对象
   + 由浏览器提供的对象
   + 如`window`、`document`...
   + 说白了就是`BOM`、`DOM`BOM操作浏览器、DOM操作网页
   + 运行环境就是宿主
3. 自定义对象
   + 由开发人员自己创建的对象

